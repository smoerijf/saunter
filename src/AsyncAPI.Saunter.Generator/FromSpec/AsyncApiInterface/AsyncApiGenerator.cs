using System.Reflection;
using System.Text;
using CaseConverter;
using LEGO.AsyncAPI.Models;
using LEGO.AsyncAPI.Readers;

namespace AsyncAPI.Saunter.Generator.FromSpec.AsyncApiInterface;

internal interface IAsyncApiGenerator
{
    string GenerateAsyncApiInterfaces(GeneratorOptions options, string text, AsyncApiState state);

    string GenerateAsyncApiInterfaces(GeneratorOptions options, AsyncApiDocument asyncApiDocument, AsyncApiState state);
}

internal class AsyncApiGenerator : IAsyncApiGenerator
{
    private readonly string _version;
    private readonly string _name;

    public AsyncApiGenerator()
    {
        var assembly = Assembly.GetExecutingAssembly().GetName();

        this._version = assembly.Version!.ToString();
        this._name = assembly.Name;
    }

    private static string MakeGlobalDocumentTopic(string name) => $"TOPIC_{name.ToSnakeCase().ToUpperInvariant()}";

    public string GenerateAsyncApiInterfaces(GeneratorOptions options, string text, AsyncApiState state)
    {
        var asyncApiDocument = new AsyncApiStringReader().Read(text, out var diagnostic);
        return this.GenerateAsyncApiInterfaces(options, asyncApiDocument, state);
    }

    public string GenerateAsyncApiInterfaces(GeneratorOptions options, AsyncApiDocument asyncApiDocument, AsyncApiState state)
    {
        var sb = CreateHeader(options);

        this.AddDocumentExtension(sb, options, asyncApiDocument);

        // Commands
        this.AddInterface(sb, options, options.ClassName, $"{options.ClassName}Commands", new("SubscribeOperation", "command", x => x.Subscribe), asyncApiDocument.Channels.Where(x => x.Value.Subscribe != null));
        sb.AppendLine();

        // Events
        this.AddInterface(sb, options, options.ClassName, $"{options.ClassName}Events", new("PublishOperation", "evt", x => x.Publish), asyncApiDocument.Channels.Where(x => x.Value.Publish != null));

        sb.AppendLine("}"); // close namespace
        sb.AppendLine();

        state.Documents.Add(options.ClassName);
        var contents = sb.ToString();
        return contents;
    }

    public void AddDocumentExtension(StringBuilder sb, GeneratorOptions options, AsyncApiDocument asyncApiDocument)
    {
        var extensionsClassName = $"{options.ClassName}AsyncApiDocumentExtensions";
        sb.AppendLine(this.GetGeneratedCodeAttributeLine());

        // TODO: AsyncApiDocument will just become the LEGO AsyncApiDocument at some point.
        sb.AppendLine(
            $$"""
                 public static class {{extensionsClassName}}
                 {
                     public static IServiceCollection AddAsyncApi{{options.ClassName}}(this IServiceCollection services)
                     {
                         services.AddAsyncApiSchemaGeneration(options =>
                         {
                             options.AssemblyMarkerTypes = [typeof({{extensionsClassName}})];
                         
                             options.Middleware.UiTitle = "{{asyncApiDocument.Info.Title}}";
                             
                             options.AsyncApi = new AsyncApiDocument
                             {
                                 Info = new Info("{{asyncApiDocument.Info.Title}}", "{{asyncApiDocument.Info.Version}}")
                                 {
                                     Description = "{{asyncApiDocument.Info.Description}}",
                                     License = new License("{{asyncApiDocument.Info.License.Name}}")
                                     {
                                         Url = "{{asyncApiDocument.Info.License.Url}}"
                                     }
                                 },
                             };
                         });
                         return services;
                     }
                 }
                 
             """);
    }

    private StringBuilder CreateHeader(GeneratorOptions options)
    {
        var sb = new StringBuilder(
            $$"""
              //----------------------
              // <auto-generated>
              //     Generated using {{this._name}} v{{this._version}}
              //     At: {{DateTime.Now.ToLocalTime():U}}
              // </auto-generated>
              //----------------------
              
              using Saunter;
              using Saunter.Attributes;
              using Saunter.AsyncApiSchema.v2;
              using System.CodeDom.Compiler;
              using Microsoft.Extensions.DependencyInjection;

              namespace {{options.Namespace}}
              {
              {{this.GetGeneratedCodeAttributeLine()}}
                  public static partial class {{options.TopicsClassName}}
                  {
              """);

        sb.AppendLine();
        sb.AppendLine($"        public const string {MakeGlobalDocumentTopic(options.ClassName)} = \"{options.ClassName.ToPascalCase()}\";");
        sb.AppendLine("    }");
        sb.AppendLine();
        return sb;
    }

    private string GetGeneratedCodeAttributeLine() => $"    [GeneratedCodeAttribute(\"{this._name}\", \"{this._version}\")]";

    private void AddInterface(StringBuilder sb, GeneratorOptions genOptions, string specName, string className, OperationOptions options, IEnumerable<KeyValuePair<string, AsyncApiChannel>> channels)
    {
        sb.AppendLine($"    [AsyncApi({genOptions.TopicsClassName}.{MakeGlobalDocumentTopic(specName)})]");
        sb.AppendLine(this.GetGeneratedCodeAttributeLine());
        sb.AppendLine($"    public interface I{className}");
        sb.Append("    {");

        foreach (var channel in channels)
        {
            AddChannelOperation(sb, options, channel);
        }

        sb.AppendLine("    }");
    }

    private record OperationOptions(string OperationAttribute, string VarName, Func<AsyncApiChannel, AsyncApiOperation> OperationProvider);

    private static void AddChannelOperation(StringBuilder sb, OperationOptions options, KeyValuePair<string, AsyncApiChannel> channel)
    {
        var operation = options.OperationProvider(channel.Value);

        sb.AppendLine();
        sb.AppendLine($"        [Channel(\"{channel.Key}\")]");
        var channelParametersSb = new StringBuilder();
        foreach (var channelParameter in channel.Value.Parameters)
        {
            var refName = FromReference(channelParameter.Value.Reference.Reference);
            var typeName = refName.ToPascalCase();
            if (channelParameter.Value.Schema.Enum.Any())
            {
                typeName += "s";
            }
            var varName = refName.ToCamelCase();
            sb.AppendLine($"        [ChannelParameter(\"{channelParameter.Key}\", typeof({typeName}), Description = \"{channelParameter.Value.Description}\")]");

            channelParametersSb.Append(", ");
            channelParametersSb.Append(typeName);
            channelParametersSb.Append(" ");
            channelParametersSb.Append(varName);
        }

        var msg = operation.Message.Single();
        var msgTypeName = (msg.Name ?? msg.Payload.Reference.Id).ToPascalCase();
        sb.AppendLine($"        [{options.OperationAttribute}(typeof({msgTypeName}), Summary = \"{operation.Summary}\", Description = \"{operation.Description}\")]");
        sb.Append($"        void {operation.OperationId}({msgTypeName} {options.VarName}");
        sb.Append(channelParametersSb);
        sb.AppendLine(");");
    }

    private static string FromReference(string reference)
    {
        const string prefix = "#/components/parameters/";
        if (reference.IndexOf(prefix, StringComparison.OrdinalIgnoreCase) == 0)
        {
            return reference.Substring(prefix.Length);
        }
        throw new ArgumentException($"Invalid reference: {reference}");
    }
}
